## ---------------------------------------------------
##  PIKO KOSTAL Dataservice
##
##  HARDWARE: HARDWARE: ESP32 240MHz, 520KB RAM, 4MB Flash
##
##  Get the data from the KOSTAL Solar Electric Pico 5.5
##
## ---------------------------------------------------

substitutions:
  # device settings
  device_name_short: "kostal-piko"
  device_description: "TESTCASE: Read data from KOSTAL Solar Electric Pico 5.5 inverter w/o historydata"
  projectname: "kostal.piko"
  friendly_name: "kostal"
  appversion: "1.0.0"
  domain: !secret domain

  ## all for the data service
  dataurl: !secret kostal_url

  ## dataurl: !secret kostal_testurl2
  datatesturl: !secret kostal_testurl1

  ## update interval for kostal pico 5.5 inverter data
  datadelay: 5min

  ## 0: Production mode - get data from the kostal pico 5.5 inverter
  ## 1: Testcase for data simulation (no http request)
  ## 3: Testcase for data simulation with github http request
  simulatedata: "0"

  ## logger settings
  log_level: "VERBOSE" # use WARN for production mode to save memory.
  log_baud: "0" # use 0 to disable serial UART port logging.

  ## device configuration
  ## HARDWARE: HARDWARE: ESP32 240MHz, 520KB RAM, 4MB Flash
  ## RAM:   [=         ]   8.2% (used 43740 bytes from 532480 bytes)
  ## Flash: [======    ]  59.5% (used 1091733 bytes from 1835008 bytes)
  board: "az-delivery-devkit-v4"

## ------------------------
## BOARD
## ------------------------
esp32:
  board: ${board}
  # platform: espressif32

# Customize the frequency in which data is flushed to the flash.
preferences:
  flash_write_interval: 10min

## ------------------------
## APPLICATION ESPHOME
## ------------------------
esphome:
  name: "${device_name_short}"
  comment: "${device_description}"
  friendly_name: ${friendly_name}
  # Automatically add the mac address to the name
  # so you can use a single firmware for all devices
  name_add_mac_suffix: false
  build_path: ./build/${device_name_short}
  # additiona compile otions
  platformio_options:
    platform: espressif32
    board: az-delivery-devkit-v4
    board_build.mcu: esp32
    board_build.f_cpu: 240000000L
    ## larger stack size required with all registers enable_load_test
    build_flags:
      - "-DCONFIG_ARDUINO_LOOP_STACK_SIZE=32768"
  project:
    name: ${projectname}
    version: ${appversion}
  on_boot:
    # priority: -100.0
    then:
      - globals.set:
          id: boot_counter
          value: !lambda "return id(boot_counter)+=1;"
      - logger.log:
          level: WARN
          format: "BOOTMESSAGE:${device_name_short} API is connected, Device ready!"
      - component.update: bootcounter
      # - text_sensor.template.publish:
      #     id: device_lastBoot_time
      #     state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");
  on_shutdown:
    # - priority: 700.0
    then:
      - logger.log:
          level: WARN
          format: "${device_name_short} is down!"

## ------------------------
## WIFI Settings
## ------------------------
wifi:
  id: esp_wifi
  networks:
    - ssid: !secret ssid3_name
      password: !secret ssid3_pswd
      priority: 0
    - ssid: !secret ssid1_name
      password: !secret ssid1_pswd
      priority: 1
    - ssid: !secret ssid2_name
      password: !secret ssid2_pswd
      priority: 2
  # manual_ip:
  #   static_ip: 10.1.1.1
  #   gateway: 10.1.1.254
  #   subnet: 255.255.255.0
  #   dns1: 10.1.1.254
  domain: !secret domain

## ------------------------
## mDNS Component
## ------------------------
mdns:
  # if mDNS is disabled, they will no longer be
  # able to automatically find your devices.
  disabled: false

## ------------------------
## Captive Portal Component
## ------------------------
captive_portal:

## ------------------------
## External Components
## ------------------------
external_components:
  # optinal: use local component from
  # https://github.com/zdzichu6969/esphome-components
  - source:
      type: local
      path: custom_components
    components: [backup]

  # optinal: use local component from
  # https://github.com/TheStaticTurtle/esphome_syslog
  - source:
      type: local
      path: custom_components
    components: [syslog]

## ------------------------
## COMPONENT syslog
## ------------------------
syslog:
  ip_address: !secret syslog_server
  port: !secret syslog_port
  min_level: DEBUG
  enable_logger: true

## ------------------------
## COMPONENT backup
## ------------------------
backup:
  auth:
    username: !secret web_username
    password: !secret web_password
  force_update: false

## ------------------------
## COMPONENT WEBSERVER
## ------------------------
web_server:
  port: 80
  version: 2
  # set the url for the internal webserver
  js_url: !secret webserver_jsurl

## ------------------------
## COMPONENT OTA
## ------------------------
ota:
  password: !secret ota_pswd
  safe_mode: false
  on_begin:
    then:
      - logger.log:
          format: "OTA START"
          level: WARN
  on_progress:
    then:
      - logger.log:
          level: WARN
          format: "OTA progress %0.1f%%"
          args: ["x"]
  on_end:
    then:
      - logger.log:
          format: "OTA END"
          level: WARN
  on_error:
    then:
      - logger.log:
          format: "OTA update error %d"
          level: ERROR
          args: ["x"]

## ------------------------
## COMPONENT Native API
## ------------------------
api:
  id: espapi_kostal_piko
  port: 6053
  reboot_timeout: 0s
  encryption:
    key: "QxRJRnm/Luj2viO8BQn+eZuf1nPvvcAbTb9qGzOHULs="

## ------------------------
# Global variables
## ------------------------
globals:
  - id: boot_counter
    type: int
    restore_value: yes
    initial_value: "0"

  # - id: historydata
  #   type: float[6]
  #   restore_value: yes
  #   ## hour_value = historydata[0]
  #   ## yesterday_value = historydata[2]
  #   ## week_value = historydata[3]
  #   ## month_value = historydata[4]
  #   ## lastmonth_value = historydata[5]
  #   ## year_value = historydata[6]
  #   initial_value: '{0.00,0.00,0.00,0.00,0.00,0.00}'
  
  - id: pikostateon
    type: std::string
    restore_value: no
    initial_value: '"Einspeisen MPP"'

  - id: send_millisecond
    type: int
    restore_value: no
    initial_value: "0"

## ------------------------
## COMPONENT Logger
## ------------------------
logger:
  id: mylogger
  level: ${log_level}
  baud_rate: ${log_baud}
  logs:
    sensor: ERROR
    internal_temperature: ERROR
    develop: DEBUG # VERBOSE
    json: ERROR

## ------------------------
## COMPONENT Time server
## ------------------------
time:
  - platform: sntp
    id: time_sntp
    timezone: Europe/Berlin
    servers:
      - 0.at.pool.ntp.org
      - 0.pool.ntp.org
      - 1.pool.ntp.org

    on_time_sync:
      # Components should trigger on_time_sync when they update the system clock.
      then:
        - logger.log:
            level: WARN
            tag: "system"
            format: "Synchronized sntp clock"
        - if:
            condition:
              lambda: 'return id(device_lastBoot_time).state == "";'
            then:
              - logger.log:
                  level: WARN
                  tag: "system"
                  format: "Init last boot time and run data service"
              # update the boot timestamp
              - text_sensor.template.publish:
                  id: device_lastBoot_time
                  state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

## ------------------------
## COMPONENT SUN
## ------------------------
sun:
  id: sunhome
  latitude: !secret home_latitude
  longitude: !secret home_longitude

## ------------------------
## COMPONENT http_request
## ------------------------
http_request:
  id: http_request_data
  useragent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/113.0"
  # timeout (Optional, Time): Timeout for request. Defaults to 5s.

## ------------------------
## ALL SCRIPTS
## ------------------------
script:
  # save the global vars
  - id: script_save_changes
    mode: restart
    then:
      - delay: 3s
      - lambda: global_preferences->sync();

  # - id: showMemoryusage
  #   then:
  #     - logger.log:
  #         format: "Memory FreeHeap:%f, HeapFrag:%f, MaxFree:%f, Sketch:%f, Sketchfree:%f"
  #         tag: "develop"
  #         level: DEBUG
  #         args:
  #            - ESP.getFreeHeap()
  #            - ESP.getHeapFragmentation()
  #            - ESP.getMaxFreeBlockSize()
  #            - ESP.getSketchSize()
  #            - ESP.getFreeSketchSpace()

  # - id: testKostalData
  #   then:
  #     - lambda: |-
  #         std::vector<double> values(15, 0.00);
  #         std::regex state_regex("<td colspan=\"4\">.(.*?)</td>", std::regex_constants::icase | std::regex_constants::ECMAScript | std::regex_constants::optimize);
  #         std::smatch state_match;
  #         std::string state;
  #         if (std::regex_search(src, state_match, state_regex)) {
  #             state = state_match[1].str();
  #             std::regex result_regex("<td width=\"70\" align=\"right\" bgcolor=\"FFFFFF\">.(.*?)</td>");
  #             std::sregex_iterator result_iterator(src.begin(), src.end(), result_regex);
  #             std::sregex_iterator end_iterator;
  #             int i = 0;
  #             while (result_iterator != end_iterator && i < 15) {
  #                 std::string d = remove_html_tags(result_iterator->suffix().str());
  #                 values[i] = (d == "x x x&nbsp") ? 0.00 : std::stod(d);
  #                 ++result_iterator;
  #                 ++i;
  #             }
  #         } else {
  #             state = "Aus";
  #         }

  # simple testcase for the kostal pico data w/o http connection
  - id: simulateKostalData

    then:
      - logger.log:
          tag: "system"
          level: WARN
          format: "Start Simulate Data"

      # create and publish the testdata
      - lambda: |-

          // kostal_aktuell: AC-Leistung_Aktuell simple simulation based on sun_elevation
          float acLeistungAktuellFloat = 0.00;
          if(id(sun_elevation).state>28 and id(sun_elevation).has_state()){
            acLeistungAktuellFloat = (id(sun_elevation).state * 52.5) * 0.485;
          }
          ESP_LOGD("develop", "AC-Leistung_Aktuell: %.2f", acLeistungAktuellFloat);
          id(kostal_aktuell).publish_state(acLeistungAktuellFloat);

          // kostal_status: AC_Leistung_Status
          if(acLeistungAktuellFloat>0.00){
            id(kostal_status).publish_state(id(pikostateon));
          }else{
            id(kostal_status).publish_state("Aus");
          }

          // kostal_total: Energie_Gesamtertrag
          float energieGesamtertragFloat = 39000.00 + (acLeistungAktuellFloat * 0.001);
          ESP_LOGD("develop", "AC-Energie_Gesamtertrag: %.2f", energieGesamtertragFloat);
          id(kostal_total).publish_state(energieGesamtertragFloat);

          // kostal_day: Energie_Tagesertrag_Aktuell
          if(id(kostal_day).has_state() ) {
            id(kostal_day).publish_state( id(kostal_day).state + (acLeistungAktuellFloat*0.001) );
          }else{
            id(kostal_day).publish_state( acLeistungAktuellFloat*0.001 );
          }

          // kostal_l1_power: Ausgangsleistung_L1_Leistung
          float pvGeneratorString1PowerFloat = 0.00;

          // kostal_l2_power: Ausgangsleistung_L2_Leistung
          float pvGeneratorString2PowerFloat = 0.00;

          if(id(time_sntp).now().hour<12.00 and acLeistungAktuellFloat>0.00){
            pvGeneratorString1PowerFloat = acLeistungAktuellFloat;
          }else{
            pvGeneratorString2PowerFloat = acLeistungAktuellFloat;
          }

          ESP_LOGD("develop", "Ausgangsleistung_L1_Leistung: %.2f", pvGeneratorString1PowerFloat);
          id(kostal_l1_power).publish_state(pvGeneratorString1PowerFloat);
          ESP_LOGD("develop", "Ausgangsleistung_L2_Leistung: %.2f", pvGeneratorString2PowerFloat);
          id(kostal_l2_power).publish_state(pvGeneratorString2PowerFloat);
          id(kostal_l3_power).publish_state(0.00);

          float pvPower = pvGeneratorString1PowerFloat+pvGeneratorString2PowerFloat;
          ESP_LOGD("develop", "Total Power: Ost+West: %.2f", pvPower);

          // kostal_power_east / kostal_power_west: Anteil Leistung Ost / West
          float powerRatioEast = 0.00;
          float powerRatioWest = 0.00;
          if(pvPower){
            powerRatioEast = (pvGeneratorString1PowerFloat / pvPower) * 100;
            powerRatioWest = (pvGeneratorString2PowerFloat / pvPower) * 100;
          }
          id(kostal_power_east).publish_state(powerRatioEast);
          id(kostal_power_west).publish_state(powerRatioWest);
          ESP_LOGD("develop", "PV Power ratio: Ost: %.2f, West: %.2f", powerRatioEast, powerRatioWest);

      - text_sensor.template.publish:
          id: kostal_datatime
          state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

      - sensor.template.publish:
          id: kostal_data_timeout
          state: !lambda |-
            int time_used = ( millis() - id(send_millisecond) );
            id(send_millisecond) = millis();
            return float(time_used)/1000;

      - logger.log:
          tag: "system"
          level: WARN
          format: "End Simulate Data"

  # get the kostal pico data (production mode) - get the data from the kostal pico inverter
  - id: readKostalPicoData
    then:
      - logger.log:
          tag: "system"
          level: WARN
          format: "Start get Data"

      - http_request.get:
          url: ${dataurl}
          verify_ssl: false
          on_response:
            - then:
                - logger.log:
                    format: "Response status: %d, Duration: %u ms"
                    tag: "develop"
                    level: DEBUG
                    args:
                      - status_code
                      - duration_ms
            - then:
                if:
                  condition:
                    lambda: return status_code == 200;
                  then:
                    - logger.log:
                        format: "Response status: %d, Duration: %u ms"
                        tag: "develop"
                        level: DEBUG
                        args:
                          - status_code
                          - duration_ms

                    # @TODO: find a better method to parse the html data
                    - lambda: |-

                        // get the data from the http request
                        std::string data = id(http_request_data).get_string();

                        id(kostal_webinterface_status).publish_state("Decode Data");

                        // kostal_aktuell: AC-Leistung_Aktuell Watt
                        size_t pos1 = data.find("aktuell</td>");
                        size_t pos2 = data.find("</td>", pos1 + 20);
                        std::string acLeistungAktuell = data.substr(pos1 + 65, pos2 - pos1 - 65);
                        float acLeistungAktuellFloat = 0.00;
                        if(acLeistungAktuell == "x x x&nbsp"){
                           ESP_LOGW("kostal", "Kostal is OFFLINE, AC-Leistung_Aktuell: %.2f", acLeistungAktuellFloat);
                        }else{
                          acLeistungAktuellFloat = std::stof(acLeistungAktuell);
                        }
                        id(kostal_aktuell).publish_state(acLeistungAktuellFloat);
                        ESP_LOGD("develop", "AC-Leistung_Aktuell: %.2f", acLeistungAktuellFloat);

                        // kostal_status: AC_Leistung_Status = Einspeisen MPP || Aus
                        pos1 = data.find("Status</td>");
                        pos2 = data.find("</td>", pos1 + 20);
                        std::string acLeistungStatus = data.substr(pos1 + 33, pos2 - pos1 - 33);
                        id(kostal_status).publish_state(acLeistungStatus);
                        ESP_LOGD("develop", "AC_Leistung_Status: %.2f", acLeistungStatus);

                        // kostal_total: Energie_Gesamtertrag kWh
                        pos1 = data.find("Gesamtenergie</td>");
                        pos2 = data.find("</td>", pos1 + 30);
                        std::string energieGesamtertrag = data.substr(pos1 + 70, pos2 - pos1 - 70);
                        float energieGesamtertragFloat = std::stof(energieGesamtertrag);
                        id(kostal_total).publish_state(energieGesamtertragFloat);
                        ESP_LOGD("develop", "Energie_Gesamtertrag: %.2f", energieGesamtertragFloat);

                        // kostal_day: Energie_Tagesertrag_Aktuell kWh
                        pos1 = data.find("Tagesenergie</td>");
                        pos2 = data.find("</td>", pos1 + 20);
                        std::string energieTagesertragAktuell = data.substr(pos1 + 70, pos2 - pos1 - 70);
                        float energieTagesertragAktuellFloat = std::stof(energieTagesertragAktuell);
                        id(kostal_day).publish_state(energieTagesertragAktuellFloat);
                        ESP_LOGD("develop", "Energie_Tagesertrag_Aktuell: %.2f", energieTagesertragAktuellFloat);

                        if(id(kostal_aktuell).has_state() and id(kostal_aktuell).state > 0.00){

                            // PV_Generator_String1_Spannung Volt
                            pos1 = data.find("Spannung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);
                            std::string s1Volt = data.substr(pos1 + 66, pos2 - pos1 - 66);
                            float s1VoltFloat = std::stof(s1Volt);

                            // Ausgangsleistung_L1_Spannung Volt
                            pos1 = data.find("Spannung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);

                            // PV_Generator_String1_Strom Ampere
                            pos1 = data.find("Strom</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);
                            std::string pvGeneratorString1Strom = data.substr(pos1 + 63, pos2 - pos1 - 63);
                            float pvGeneratorString1StromFloat = std::stof(pvGeneratorString1Strom);
                            ESP_LOGD("develop", "PV_Generator_String1_Strom: %.2f", pvGeneratorString1StromFloat);

                            // kostal_l1_power: Ausgangsleistung_L1_Leistung Watt
                            pos1 = data.find("Leistung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);
                            std::string pvGeneratorString1Power = data.substr(pos1 + 66, pos2 - pos1 - 66);
                            float pvGeneratorString1PowerFloat = std::stof(pvGeneratorString1Power);
                            id(kostal_l1_power).publish_state(pvGeneratorString1PowerFloat);
                            ESP_LOGD("develop", "Ausgangsleistung_L1_Leistung: %.2f", pvGeneratorString1PowerFloat);

                            // PV_Generator_String2_Spannung Volt
                            pos1 = data.find("Spannung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);
                            std::string s2Volt = data.substr(pos1 + 66, pos2 - pos1 - 66);
                            float s2VoltFloat = std::stof(s2Volt);
                            ESP_LOGD("develop", "PV_Generator_String2_Spannung: %.2f", s2VoltFloat);

                            // Ausgangsleistung_L2_Spannung Volt
                            pos1 = data.find("Spannung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);

                            // PV_Generator_String2_Strom Ampere
                            pos1 = data.find("Strom</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);
                            std::string pvGeneratorString2Strom = data.substr(pos1 + 63, pos2 - pos1 - 63);
                            float pvGeneratorString2StromFloat = std::stof(pvGeneratorString2Strom);
                            ESP_LOGD("develop", "PV_Generator_String2_Strom: %.2f", pvGeneratorString2StromFloat);

                            // kostal_l2_power: Ausgangsleistung_L2_Leistung Watt
                            pos1 = data.find("Leistung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);
                            std::string pvGeneratorString2Power = data.substr(pos1 + 66, pos2 - pos1 - 66);
                            float pvGeneratorString2PowerFloat = std::stof(pvGeneratorString2Power);
                            id(kostal_l2_power).publish_state(pvGeneratorString2PowerFloat);
                            ESP_LOGD("develop", "Ausgangsleistung_L2_Leistung: %.2f", kostal_l2_power);

                            // PV_Generator_String3_Spannung Volt
                            pos1 = data.find("Spannung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);

                            // Ausgangsleistung_L3_Spannung Volt
                            pos1 = data.find("Spannung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);

                            // PV_Generator_String3_Strom Ampere
                            pos1 = data.find("Strom</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);

                            // kostal_l3_power: Ausgangsleistung_L3_Leistung Watt
                            pos1 = data.find("Leistung</td>", pos2);
                            pos2 = data.find("</td>", pos1 + 20);
                            std::string pvGeneratorString3Power = data.substr(pos1 + 66, pos2 - pos1 - 66);
                            float pvGeneratorString3PowerFloat = std::stof(pvGeneratorString3Power);
                            id(kostal_l3_power).publish_state(pvGeneratorString3PowerFloat);
                            ESP_LOGD("develop", "Ausgangsleistung_L3_Leistung: %.2f", pvGeneratorString3PowerFloat);

                            // kostal_power_east / kostal_power_west : calc the power ratio east to west
                            float pvPowerS1 = s1VoltFloat * pvGeneratorString1StromFloat;
                            float pvPowerS2 = s2VoltFloat * pvGeneratorString2StromFloat;
                            ESP_LOGD("develop", "PV Power: Ost: %.2f, West: %.2f", pvPowerS1, pvPowerS2);

                            float pvPower = pvPowerS1+pvPowerS2;
                            ESP_LOGD("develop", "Total Power: Ost+West: %.2f", pvPower);
                            float powerRatioEast = 0.00;
                            float powerRatioWest = 0.00;
                            if(pvPower){
                              powerRatioEast = (pvPowerS1 / pvPower) * 100;
                              powerRatioWest = (pvPowerS2 / pvPower) * 100;
                            }
                            id(kostal_power_east).publish_state(powerRatioEast);
                            id(kostal_power_west).publish_state(powerRatioWest);
                            ESP_LOGD("develop", "PV Power ratio: Ost: %.2f, West: %.2f", powerRatioEast, powerRatioWest);

                        } else {

                          // Kostal piko 5.5 inverter is offline
                          id(kostal_l1_power).publish_state(0.00);
                          id(kostal_l2_power).publish_state(0.00);
                          id(kostal_l3_power).publish_state(0.00);
                          id(kostal_power_east).publish_state(0.00);
                          id(kostal_power_west).publish_state(0.00);

                        }

                        // try to clean the memory ??
                        data = "";

                        // update the state info
                        id(kostal_webinterface_status).publish_state("Ready");
                        id(kostal_webinterface_ready).publish_state(true);

                    - logger.log:
                        tag: "develop"
                        level: WARN
                        format: "End get Data"

                  else:
                    - logger.log:
                        tag: "system"
                        level: ERROR
                        format: "Kostal Webservice fatal Error"
                    - lambda: |-
                        // update the state info
                        id(kostal_status).publish_state("Aus");
                        id(kostal_webinterface_status).publish_state("Error");
                        id(kostal_webinterface_ready).publish_state(false);

            - then:
                - text_sensor.template.publish:
                    id: kostal_datatime
                    state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

                - sensor.template.publish:
                    id: kostal_data_timeout
                    state: !lambda |-
                      int time_used = ( millis() - id(send_millisecond) );
                      id(send_millisecond) = millis();
                      return float(time_used)/1000;

## ------------------------
## SWITCHES
## ------------------------
switch:
  - platform: template
    name: "Boot Counter Reset"
    icon: mdi:lock-reset
    turn_on_action:
      then:
        - lambda: id(boot_counter) = 0; id(bootcounter).publish_state(id(boot_counter));
        - logger.log:
            level: WARN
            tag: "system"
            format: "${device_name_short} reset boot counter o.k!"
        - component.update: bootcounter

  - platform: restart
    id: restart_device
    name: Device restart
    icon: mdi:restart

  - platform: safe_mode
    name: "Device restart Safe Mode"
    icon: mdi:restart

  - platform: factory_reset
    name: Device restart factory defaults
    icon: mdi:restart

## ------------------------
## BINARY SENSORS
## ------------------------
binary_sensor:
  # Einspeisen MPP
  - platform: template
    name: "Energie Produktion"
    icon: mdi:toggle-switch-variant-off
    id: kostal_production_on
    lambda: return id(kostal_status).has_state() and id(kostal_status).state == id(pikostateon);

  # Webinterface Kostal Piko ready
  - platform: template
    name: "Kostal Pico Status"
    icon: mdi:toggle-switch-variant-off
    id: kostal_webinterface_ready

## ------------------------
## SENSORS
## ------------------------
sensor:
  # aktuelle Leistung (updated by script)
  # kostal_l1_power + kostal_l2_power + kostal_l3_power
  - platform: template
    name: "Leistung aktuell"
    id: kostal_aktuell
    icon: mdi:solar-power-variant
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"
    update_interval: ${datadelay}

  # Energie Produktion pro Tag (updated by script)
  - platform: template
    name: "Energie Tag"
    id: kostal_day
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "kWh"
    update_interval: ${datadelay}

  # Energie Produktion gesamt seit installation (updated by script)
  - platform: template
    name: "Energie Gesamt"
    id: kostal_total
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "kWh"
    update_interval: ${datadelay}

  # Leistung Produktion Phase 1 (updated by script)
  - platform: template
    name: "Energie L1"
    id: kostal_l1_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"
    update_interval: ${datadelay}

  # Leistung Produktion Phase 2 (updated by script)
  - platform: template
    name: "Energie L2"
    id: kostal_l2_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"
    update_interval: ${datadelay}

  # Leistung Produktion Phase 3 (updated by script)
  - platform: template
    name: "Energie L3"
    id: kostal_l3_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"
    update_interval: ${datadelay}

  # Solar Panel Leistung (simple, just a testcase)
  # better get the current power from solcast.com
  # https://solcast.com/solar-radiation-map/europe
  - platform: template
    name: "Solar Panel Leistung"
    id: kostal_solar_panel_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: measurement
    device_class: energy
    unit_of_measurement: "W"
    lambda: |-
      if(id(sun_elevation).has_state() and id(sun_elevation).state>1.00){
       return ( (24.00*260.00*0.9) * (id(sun_elevation).state/100.00) );
      }else{
       return 0.00;
      }

  # theortischer Leistungsfakor = aktuelle Leistung / Sonnen Leistung
  - platform: template
    name: "Solar Leistungsfaktor"
    id: kostal_solar_panel_faktor
    icon: mdi:percent-outline
    accuracy_decimals: 2
    state_class: measurement
    unit_of_measurement: "%"
    lambda: |-
      if(id(kostal_aktuell).has_state() and id(kostal_solar_panel_power).has_state() and id(kostal_solar_panel_power).state>0.00){
         return id(kostal_aktuell).state / id(kostal_solar_panel_power).state;
      }else{
         return 0.00;
      }

  # Leistung Produktions Anteil Ost (updated by script)
  - platform: template
    name: "Energie Anteil Ost"
    id: kostal_power_east
    icon: mdi:home-percent-outline
    accuracy_decimals: 2
    state_class: measurement
    unit_of_measurement: "%"
    update_interval: ${datadelay}

  # Leistung Produktions Anteil Ost (updated by script)
  - platform: template
    name: "Energie Anteil West"
    id: kostal_power_west
    icon: mdi:home-percent-outline
    accuracy_decimals: 2
    state_class: measurement
    unit_of_measurement: "%"
    update_interval: ${datadelay}

  # aktuelle Sonnenhöhe
  # default: updates based on the datadelay settings
  - platform: sun
    name: Sonnehöhe
    id: sun_elevation
    type: elevation
    update_interval: ${datadelay}
    on_value:
      then:
        - logger.log:
            level: WARN
            format: "sun_elevation changed"
        # get the data from the kostal pico inverter
        # if the sun_elevation change.
        - if:
            condition:
              lambda: "return ${simulatedata} == 0;"
            then:
              - script.execute: readKostalPicoData
              - script.wait: readKostalPicoData
            else:
              - script.execute: simulateKostalData
              - script.wait: simulateKostalData

  # aktuelle Sonnenrichtung
  - platform: sun
    name: Sonnenrichtung
    id: sun_anzimuth
    type: azimuth
    update_interval: ${datadelay}

  # Wifi quality RSSI (%)
  - platform: wifi_signal
    name: "Device WLAN Signal"
    id: wifi_signal_db
    update_interval: 60s
    icon: mdi:wifi
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    entity_category: "diagnostic"
    unit_of_measurement: "%"

  # Uptime device in hours
  - platform: uptime
    name: Device online seit
    id: uptime_human
    icon: mdi:clock-start
    filters:
      - lambda: return x / 3600;
    unit_of_measurement: "h"
    entity_category: "diagnostic"
    state_class: "measurement"
    accuracy_decimals: 2

  # device internal temperature (only webview)
  - platform: internal_temperature
    name: Device Internal Temperature
    id: device_internal_temperature
    icon: mdi:thermometer-lines
    state_class: "measurement"
    update_interval: 60s
    entity_category: "diagnostic"
    disabled_by_default: true

  # device boot counter by device boot
  - platform: template
    name: "Boot counter"
    id: bootcounter
    icon: mdi:counter
    accuracy_decimals: 0
    state_class: "measurement"
    entity_category: "diagnostic"
    lambda: return (id(boot_counter));
    update_interval: ${datadelay}

  # the current size of free heap memory.
  - platform: template
    name: Free Heap Min
    lambda: return {static_cast<float>(esp_get_minimum_free_heap_size())};
    unit_of_measurement: B
    update_interval: 2s
    entity_category: "diagnostic"

  # Minimum free heap ever available
  - platform: template
    name: Free Heap
    lambda: return {static_cast<float>(esp_get_free_heap_size())};
    unit_of_measurement: B
    update_interval: 2s
    entity_category: "diagnostic"

  # service call delay (updated by script)
  - platform: template
    name: Kostal Daten Intervall
    id: kostal_data_timeout
    icon: mdi:clock-start
    accuracy_decimals: 2
    unit_of_measurement: "sec"
    state_class: "measurement"
    entity_category: "diagnostic"
    update_interval: ${datadelay}

## ------------------------
## TEXT SENSORS
## ------------------------
text_sensor:
  # Kostal status (updated by script)
  - platform: template
    name: "Kostal Pico Status"
    disabled_by_default: true
    icon: mdi:alarm-note
    id: kostal_status
    update_interval: ${datadelay}

  # Kostal webinterface status (updated by script)
  - platform: template
    name: "Kostal Pico Verbindung"
    id: kostal_webinterface_status
    icon: mdi:alarm-note
    update_interval: ${datadelay}

  # Kostal Daten Zeitstempel (updated by script)
  - platform: template
    name: "Kostal Pico Timestamp"
    disabled_by_default: true
    id: kostal_datatime
    icon: mdi:clock-start
    update_interval: ${datadelay}

  # Zeit Sonnenaufgang
  - platform: sun
    name: Sonnenaufgang am
    type: sunrise
    update_interval: ${datadelay}

  # Zeit Sonnenaufgang
  - platform: sun
    name: Sonnenuntergang am
    type: sunset
    update_interval: ${datadelay}

  # Last boot timestamp (updated by device boot)
  - platform: template
    name: "Device Last Boot"
    disabled_by_default: true
    id: device_lastBoot_time
    icon: mdi:clock-start
    update_interval: ${datadelay}
    on_value:
      then:
        - logger.log:
            level: DEBUG
            format: "device_lastBoot_time changed"
        # init, try to get the data
        - if:
            condition:
              lambda: "return ${simulatedata} == 0;"
            then:
              - script.execute: readKostalPicoData
              - script.wait: readKostalPicoData
            else:
              - script.execute: simulateKostalData
              - script.wait: simulateKostalData

  # optional device timestamp (only for webserver)
  # default: updates every minute (60s)
  - platform: template
    id: systime
    name: Device Uhrzeit
    disabled_by_default: true
    icon: mdi:clock-start
    lambda: return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

  # connected to ssid (only for webserver)
  - platform: wifi_info
    ssid:
      name: Device WLAN SSID
      id: wlan_ssid
      disabled_by_default: true
      icon: mdi:wifi-settings

  # installed esphome version
  - platform: version
    name: "ESPHome Version"
    hide_timestamp: true
    disabled_by_default: true
    icon: mdi:information-box-outline
