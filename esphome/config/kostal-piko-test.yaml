---
substitutions:
  # device settings
  device_name_short: "kostal-piko"
  device_description: "TESTCASE: Read data from KOSTAL Solar Electric Pico 5.5 inverter w/o historydata"
  projectname: "kostal.piko"
  friendly_name: "kostal"
  appversion: "1.0.0"
  domain: !secret domain

  datadelay: 5min ## update interval for kostal pico 5.5 inverter data
  
  data_kostalurl:  !secret kostal_url
  data_kostalurl1: !secret kostal_testurl1
  data_kostalurl2: !secret kostal_testurl2

  ## logger settings
  log_level: "VERBOSE" # use WARN for production mode to save memory.
  log_baud: "115200" # use 0 to disable serial UART port logging.

  ## ------------------------------------------------------
  ## device configuration
  ## ------------------------------------------------------
  ## HARDWARE: ESP32 240MHz, 520KB RAM, 4MB Flash
  ## RAM:   [=         ]   8.2% (used 43740 bytes from 532480 bytes)
  ## Flash: [======    ]  59.5% (used 1091733 bytes from 1835008 bytes)
  board: "az-delivery-devkit-v4"

# az-delivery-devkit-v4 crashes running some code. How to troubleshoot it?

## ------------------------
## BOARD
## ------------------------
esp32:
  board: ${board}

# Customize the frequency in which data is flushed to the flash.
preferences:
  flash_write_interval: 10min

## ------------------------
## APPLICATION ESPHOME
## ------------------------
esphome:
  name: "${device_name_short}"
  comment: "${device_description}"
  friendly_name: ${friendly_name}
  # Automatically add the mac address to the name
  # so you can use a single firmware for all devices
  name_add_mac_suffix: false
  # save build to this folder
  build_path: ./build/${device_name_short}
  # additiona compile options (do we need this ??)
  platformio_options:
    platform: espressif32
    board: az-delivery-devkit-v4
    ## larger stack size required with all registers enable_load_test
    build_flags:
      - "-DCONFIG_ARDUINO_LOOP_STACK_SIZE=32768"
  project:
    name: ${projectname}
    version: ${appversion}
  on_boot:
    then:
      - globals.set:
          id: boot_counter
          value: !lambda "return id(boot_counter)+=1;"
      - logger.log:
          level: WARN
          format: "BOOTMESSAGE:${device_name_short} API is connected, Device ready!"
      - component.update: bootcounter
  on_shutdown:
    then:
      - logger.log:
          level: WARN
          format: "${device_name_short} is down!"

## ------------------------
## WIFI Settings
## ------------------------
wifi:
  id: esp_wifi
  networks:
    - ssid: !secret ssid3_name
      password: !secret ssid3_pswd
      priority: 0
    - ssid: !secret ssid1_name
      password: !secret ssid1_pswd
      priority: 1
    - ssid: !secret ssid2_name
      password: !secret ssid2_pswd
      priority: 2
  # manual_ip:
  #   static_ip: 10.1.1.1
  #   gateway: 10.1.1.254
  #   subnet: 255.255.255.0
  #   dns1: 10.1.1.254
  domain: !secret domain

## ------------------------
## mDNS Component
## ------------------------
mdns:
  # if mDNS is disabled, they will no longer be
  # able to automatically find your devices.
  disabled: false

## ------------------------
## Captive Portal Component
## ------------------------
captive_portal:

## ------------------------
## External Components
## ------------------------
external_components:
  # optinal: use local component from
  # https://github.com/zdzichu6969/esphome-components
  - source:
      type: local
      path: custom_components
    components: [backup]

  # optinal: use local component from
  # https://github.com/TheStaticTurtle/esphome_syslog
  - source:
      type: local
      path: custom_components
    components: [syslog]

## ------------------------
## COMPONENT syslog
## ------------------------
syslog:
  ip_address: !secret syslog_server
  port: !secret syslog_port
  min_level: ${log_level}
  enable_logger: true

## ------------------------
## COMPONENT backup
## ------------------------
backup:
  auth:
    username: !secret web_username
    password: !secret web_password
  force_update: false

## ------------------------
## COMPONENT WEBSERVER
## ------------------------
web_server:
  port: 80
  version: 1

## ------------------------
## COMPONENT OTA
## ------------------------
ota:
  password: !secret ota_pswd
  safe_mode: false
  on_begin:
    then:
      - logger.log:
          format: "OTA START"
          level: WARN
  on_progress:
    then:
      - logger.log:
          level: WARN
          format: "OTA progress %0.1f%%"
          args: ["x"]
  on_end:
    then:
      - logger.log:
          format: "OTA END"
          level: WARN
  on_error:
    then:
      - logger.log:
          format: "OTA update error %d"
          level: ERROR
          args: ["x"]

## ------------------------
## COMPONENT Native API
## ------------------------
api:
  id: espapi_kostal_piko
  port: 6053
  reboot_timeout: 0s
  # https://esphome.io/components/api.html?highlight=api
  encryption:
    key: "W4WIEqYQWyu/hIb8KZTuljH4g77Xr66SKEpvlJP65iI="

## ------------------------
# Global variables
## ------------------------
globals:
  - id: boot_counter
    type: int
    restore_value: yes
    initial_value: "0"

  # history data
  - id: hour_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: yesterday_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: week_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: month_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: lastmonth_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: year_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: last_value
    type: float
    restore_value: no
    initial_value: "0.00"

  - id: kwhpeak
    type: float
    restore_value: no
    initial_value: "6240.00"

  - id: pikostateon
    type: std::string
    restore_value: no
    initial_value: '"Einspeisen MPP"'

  - id: send_millisecond
    type: int
    restore_value: no
    initial_value: "0"

  - id: sunon
    type: int
    restore_value: no
    initial_value: "1"

## ------------------------
## COMPONENT Logger
## ------------------------
logger:
  id: mylogger
  level: ${log_level}
  baud_rate: ${log_baud}
  logs:
    develop: DEBUG
    json: ERROR
    internal_temperature: ERROR
    sensor: WARN
    text_sensor: WARN

## ------------------------
## COMPONENT Time server
## ------------------------
time:
  - platform: sntp
    id: time_sntp
    timezone: Europe/Berlin
    servers:
      - !secret local_sntp
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    on_time_sync:
      # Components should trigger on_time_sync when they update the system clock.
      then:
        - logger.log:
            level: WARN
            tag: "system"
            format: "Synchronized sntp clock"
        - if:
            condition:
              lambda: 'return id(device_lastBoot_time).state == "";'
            then:
              - logger.log:
                  level: WARN
                  tag: "system"
                  format: "Init last boot time and run data service"
              # update the boot timestamp
              - text_sensor.template.publish:
                  id: device_lastBoot_time
                  state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

## ------------------------
## COMPONENT SUN
## ------------------------
sun:
  id: sunhome
  latitude: !secret home_latitude
  longitude: !secret home_longitude
  on_sunrise:
    - then:
        - logger.log:
            tag: "system"
            level: INFO
            format: "Sun is now rise"
        - globals.set:
            id: sunon
            value: "1"
  on_sunset:
    - then:
        - logger.log:
            tag: "system"
            level: INFO
            format: "Sun is now down"
        - globals.set:
            id: sunon
            value: "0"

## ------------------------
## COMPONENT http_request
## ------------------------
http_request:
  id: http_request_data
  useragent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/113.0"
  # timeout (Optional, Time): Timeout for request. Defaults to 5s.
  timeout: 800ms

## ------------------------
## COMPONENT INTERVALL
## ------------------------
interval:
  - interval: ${datadelay}
    then:
      # get the data from the kostal pico inverter
      - script.execute: loadKostalData          
      - script.wait: loadKostalData

## ------------------------
## ALL SCRIPTS
## ------------------------
script:
  # save the global vars (not used, only a testcase)
  - id: script_save_changes
    mode: restart
    then:
      - delay: 3s
      - lambda: global_preferences->sync();

  # show the used memory (not used, only a testcase)
  # - id: showMemoryusage
  #   then:
  #     - logger.log:
  #         format: "Memory FreeHeap:%f, HeapFrag:%f, MaxFree:%f, Sketch:%f, Sketchfree:%f"
  #         tag: "develop"
  #         level: DEBUG
  #         args:
  #            - ESP.getFreeHeap()
  #            - ESP.getHeapFragmentation()
  #            - ESP.getMaxFreeBlockSize()
  #            - ESP.getSketchSize()
  #            - ESP.getFreeSketchSpace()

  # try to get the data (not working !)
  # - id: testKostalData
  #   then:
  #     - lambda: |-
  #         std::vector<double> values(15, 0.00);
  #         std::regex state_regex("<td colspan=\"4\">.(.*?)</td>", std::regex_constants::icase | std::regex_constants::ECMAScript | std::regex_constants::optimize);
  #         std::smatch state_match;
  #         std::string state;
  #         if (std::regex_search(src, state_match, state_regex)) {
  #             state = state_match[1].str();
  #             std::regex result_regex("<td width=\"70\" align=\"right\" bgcolor=\"FFFFFF\">.(.*?)</td>");
  #             std::sregex_iterator result_iterator(src.begin(), src.end(), result_regex);
  #             std::sregex_iterator end_iterator;
  #             int i = 0;
  #             while (result_iterator != end_iterator && i < 15) {
  #                 std::string d = remove_html_tags(result_iterator->suffix().str());
  #                 values[i] = (d == "x x x&nbsp") ? 0.00 : std::stod(d);
  #                 ++result_iterator;
  #                 ++i;
  #             }
  #         } else {
  #             state = "Aus";
  #         }

  # start reading kostal data
  - id: loadKostalData    
    then:
      if:
        condition:
          lambda: return id(datamode).active_index().has_value() and id(datamode).active_index() == 0;
        then:
          - script.execute: simulateKostalData              
          - script.wait: simulateKostalData
        else:                     
          - script.wait: readKostalPicoData
          - script.wait: readKostalPicoData  

  # simple testcase for the kostal pico data w/o http connection
  - id: simulateKostalData
    then:
      - logger.log:
          tag: "system"
          level: WARN
          format: "Start Simulate Data"

      # create and publish the testdata
      - lambda: |-

          id(kostal_webinterface_status).publish_state("Simulate");

          id(sysfreemapmin).update();
          id(sysfreeheap).update();

          // kostal_aktuell: AC-Leistung_Aktuell simple simulation based on sun_elevation           
          if(id(sun_elevation).has_state() and id(sun_elevation).state>28 ){            
            id(kostal_aktuell).publish_state((id(sun_elevation).state * 52.5) * 0.485);
          }else{
            id(kostal_aktuell).publish_state(0.00);
          }
          ESP_LOGD("develop", "AC-Leistung_Aktuell: %.2f", id(kostal_aktuell).state);

          // kostal_status: AC_Leistung_Status
          if(id(kostal_aktuell).state>0.00){
            id(kostal_status).publish_state(id(pikostateon));
          }else{
            id(kostal_status).publish_state("Aus");
          }

          // kostal_total: Energie_Gesamtertrag          
          id(kostal_total).publish_state(39000.00 + (id(kostal_aktuell).state * 0.001));
          ESP_LOGD("develop", "AC-Energie_Gesamtertrag: %.2f", id(kostal_total).state);

          // kostal_day: Energie_Tagesertrag_Aktuell
          if(id(kostal_day).has_state() ) {
            id(kostal_day).publish_state( id(kostal_day).state + (id(kostal_aktuell).state*0.001) );
          }else{
            id(kostal_day).publish_state( id(kostal_aktuell).state*0.001 );
          }

          // kostal_l1_power & kostal_l2_power: Ausgangsleistung_L1_Leistung          
          if(id(time_sntp).now().hour<12.00 and id(kostal_aktuell).state>0.00){
            id(kostal_l1_power).publish_state(id(kostal_aktuell).state);            
            id(kostal_l2_power).publish_state(0.00);
          }else{
            id(kostal_l1_power).publish_state(0.00);
            id(kostal_l2_power).publish_state(id(kostal_aktuell).state);            
          }
          id(kostal_l3_power).publish_state(0.00);
          ESP_LOGD("develop", "Ausgangsleistung L1: %.2f, L2: %.2f", id(kostal_l1_power).state, id(kostal_l2_power).state);

          // kostal_power_east / kostal_power_west: Anteil Leistung Ost / West
          if(id(kostal_aktuell).state > 0.00){
            id(kostal_power_east).publish_state((id(kostal_l1_power).state / (id(kostal_l1_power).state+id(kostal_l2_power).state)) * 100);
            id(kostal_power_west).publish_state((id(kostal_l2_power).state / (id(kostal_l1_power).state+id(kostal_l2_power).state)) * 100);
          }else{
            id(kostal_power_east).publish_state(0.00);
            id(kostal_power_west).publish_state(0.00);
          }          
          ESP_LOGD("develop", "PV Power ratio: Ost: %.2f, West: %.2f", id(kostal_power_east).state, id(kostal_power_west).state);

          id(kostal_webinterface_status).publish_state("Ready");
          id(kostal_webinterface_ready).publish_state(true);

          id(sysfreemapmin).update();
          id(sysfreeheap).update();

      - text_sensor.template.publish:
          id: kostal_datatime
          state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

      - sensor.template.publish:
          id: kostal_data_timeout
          state: !lambda |-
            int time_used = ( millis() - id(send_millisecond) );
            id(send_millisecond) = millis();
            return float(time_used)/1000;

      - logger.log:
          tag: "system"
          level: WARN
          format: "End Simulate Data"

  # get the kostal pico data (production mode) - get the data from the kostal pico inverter
  - id: readKostalPicoData
    then:
      - logger.log:
          tag: "system"
          level: WARN
          format: "Start get Data"

      - http_request.get:
          url: !lambda return ((std::string) id(kostal_datasource).state).c_str();
          # url: ${data_kostalurl}
          verify_ssl: false
          on_response:
            - then:
                - logger.log:
                    format: "Response status: %d, Duration: %u ms"
                    tag: "develop"
                    level: DEBUG
                    args:
                      - status_code
                      - duration_ms
            - then:
                if:
                  condition:
                    lambda: return status_code == 200;
                  then:
                    - logger.log:
                        format: "Response status: %d, Duration: %u ms"
                        tag: "develop"
                        level: DEBUG
                        args:
                          - status_code
                          - duration_ms

                    # @TODO: find a better method to parse the html data
                    - lambda: |-

                        // get the data from the http request
                        std::string data = id(http_request_data).get_string();
                        if( !data.empty() ) {
                          id(sysfreemapmin).update();
                          id(sysfreeheap).update();

                          id(kostal_webinterface_status).publish_state("Decode Data");

                          // kostal_aktuell: AC-Leistung_Aktuell Watt
                          size_t pos1 = data.find("aktuell</td>");
                          size_t pos2 = data.find("</td>", pos1 + 20);
                          std::string acLeistungAktuell = data.substr(pos1 + 65, pos2 - pos1 - 65);
                          id(kostal_aktuell).state = 0.00;
                          if(acLeistungAktuell == "x x x&nbsp"){
                            ESP_LOGW("kostal", "Kostal is OFFLINE, AC-Leistung_Aktuell: %.2f", id(kostal_aktuell).state);
                          }else{
                            id(kostal_aktuell).state = std::stof(acLeistungAktuell);
                          }
                          id(kostal_aktuell).publish_state(id(kostal_aktuell).state);
                          ESP_LOGD("develop", "AC-Leistung_Aktuell: %.2f", id(kostal_aktuell).state);

                          // kostal_status: AC_Leistung_Status = Einspeisen MPP || Aus
                          pos1 = data.find("Status</td>");
                          pos2 = data.find("</td>", pos1 + 20);
                          std::string acLeistungStatus = data.substr(pos1 + 33, pos2 - pos1 - 33);
                          id(kostal_status).publish_state(acLeistungStatus);
                          ESP_LOGD("develop", "AC_Leistung_Status: %s", acLeistungStatus.c_str());

                          // kostal_total: Energie_Gesamtertrag kWh
                          pos1 = data.find("Gesamtenergie</td>");
                          pos2 = data.find("</td>", pos1 + 30);
                          std::string energieGesamtertrag = data.substr(pos1 + 70, pos2 - pos1 - 70);
                          float energieGesamtertragFloat = std::stof(energieGesamtertrag);
                          id(kostal_total).publish_state(energieGesamtertragFloat);
                          ESP_LOGD("develop", "Energie_Gesamtertrag: %.2f", energieGesamtertragFloat);

                          // kostal_day: Energie_Tagesertrag_Aktuell kWh
                          pos1 = data.find("Tagesenergie</td>");
                          pos2 = data.find("</td>", pos1 + 20);
                          std::string energieTagesertragAktuell = data.substr(pos1 + 70, pos2 - pos1 - 70);
                          float energieTagesertragAktuellFloat = std::stof(energieTagesertragAktuell);

                          // kostal_day: reset the kostal_day after midnight
                          if((id(time_sntp).now().hour>0.00 and id(time_sntp).now().hour<1.00) and id(kostal_aktuell).state==0.00){
                            energieTagesertragAktuellFloat = 0.00;
                          }
                          id(kostal_day).publish_state(energieTagesertragAktuellFloat);
                          ESP_LOGD("develop", "Energie_Tagesertrag_Aktuell: %.2f", energieTagesertragAktuellFloat);

                          if(id(kostal_aktuell).has_state() and id(kostal_aktuell).state > 0.00){

                              // PV_Generator_String1_Spannung Volt
                              pos1 = data.find("Spannung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);
                              std::string s1Volt = data.substr(pos1 + 66, pos2 - pos1 - 66);
                              float s1VoltFloat = std::stof(s1Volt);

                              // Ausgangsleistung_L1_Spannung Volt
                              pos1 = data.find("Spannung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);

                              // PV_Generator_String1_Strom Ampere
                              pos1 = data.find("Strom</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);
                              std::string pvGeneratorString1Strom = data.substr(pos1 + 63, pos2 - pos1 - 63);
                              float pvGeneratorString1StromFloat = std::stof(pvGeneratorString1Strom);
                              ESP_LOGD("develop", "PV_Generator_String1_Strom: %.2f", pvGeneratorString1StromFloat);

                              // kostal_l1_power: Ausgangsleistung_L1_Leistung Watt
                              pos1 = data.find("Leistung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);
                              std::string pvGeneratorString1Power = data.substr(pos1 + 66, pos2 - pos1 - 66);
                              float pvGeneratorString1PowerFloat = std::stof(pvGeneratorString1Power);
                              id(kostal_l1_power).publish_state(pvGeneratorString1PowerFloat);
                              ESP_LOGD("develop", "Ausgangsleistung_L1_Leistung: %.2f", pvGeneratorString1PowerFloat);

                              // PV_Generator_String2_Spannung Volt
                              pos1 = data.find("Spannung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);
                              std::string s2Volt = data.substr(pos1 + 66, pos2 - pos1 - 66);
                              float s2VoltFloat = std::stof(s2Volt);
                              ESP_LOGD("develop", "PV_Generator_String2_Spannung: %.2f", s2VoltFloat);

                              // Ausgangsleistung_L2_Spannung Volt
                              pos1 = data.find("Spannung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);

                              // PV_Generator_String2_Strom Ampere
                              pos1 = data.find("Strom</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);
                              std::string pvGeneratorString2Strom = data.substr(pos1 + 63, pos2 - pos1 - 63);
                              float pvGeneratorString2StromFloat = std::stof(pvGeneratorString2Strom);
                              ESP_LOGD("develop", "PV_Generator_String2_Strom: %.2f", pvGeneratorString2StromFloat);

                              // kostal_l2_power: Ausgangsleistung_L2_Leistung Watt
                              pos1 = data.find("Leistung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);
                              std::string pvGeneratorString2Power = data.substr(pos1 + 66, pos2 - pos1 - 66);
                              float pvGeneratorString2PowerFloat = std::stof(pvGeneratorString2Power);
                              id(kostal_l2_power).publish_state(pvGeneratorString2PowerFloat);
                              ESP_LOGD("develop", "Ausgangsleistung_L2_Leistung: %.2f", kostal_l2_power);

                              // PV_Generator_String3_Spannung Volt
                              pos1 = data.find("Spannung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);

                              // Ausgangsleistung_L3_Spannung Volt
                              pos1 = data.find("Spannung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);

                              // PV_Generator_String3_Strom Ampere
                              pos1 = data.find("Strom</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);

                              // kostal_l3_power: Ausgangsleistung_L3_Leistung Watt
                              pos1 = data.find("Leistung</td>", pos2);
                              pos2 = data.find("</td>", pos1 + 20);
                              std::string pvGeneratorString3Power = data.substr(pos1 + 66, pos2 - pos1 - 66);
                              float pvGeneratorString3PowerFloat = std::stof(pvGeneratorString3Power);
                              id(kostal_l3_power).publish_state(pvGeneratorString3PowerFloat);
                              ESP_LOGD("develop", "Ausgangsleistung_L3_Leistung: %.2f", pvGeneratorString3PowerFloat);

                              // kostal_power_east / kostal_power_west : calc the power ratio east to west
                              float pvPowerS1 = s1VoltFloat * pvGeneratorString1StromFloat;
                              float pvPowerS2 = s2VoltFloat * pvGeneratorString2StromFloat;
                              ESP_LOGD("develop", "PV Power: Ost: %.2f, West: %.2f", pvPowerS1, pvPowerS2);

                              float pvPower = pvPowerS1+pvPowerS2;
                              ESP_LOGD("develop", "Total Power: Ost+West: %.2f", pvPower);
                              float powerRatioEast = 0.00;
                              float powerRatioWest = 0.00;
                              if(pvPower){
                                powerRatioEast = (pvPowerS1 / pvPower) * 100;
                                powerRatioWest = (pvPowerS2 / pvPower) * 100;
                              }
                              id(kostal_power_east).publish_state(powerRatioEast);
                              id(kostal_power_west).publish_state(powerRatioWest);
                              ESP_LOGD("develop", "PV Power ratio: Ost: %.2f, West: %.2f", powerRatioEast, powerRatioWest);

                          } else {

                            // Kostal piko 5.5 inverter is offline
                            id(kostal_l1_power).publish_state(0.00);
                            id(kostal_l2_power).publish_state(0.00);
                            id(kostal_l3_power).publish_state(0.00);
                            id(kostal_power_east).publish_state(0.00);
                            id(kostal_power_west).publish_state(0.00);

                          }

                          // try to clean the memory ??
                          data = "";

                          // update the state info
                          id(kostal_webinterface_status).publish_state("Ready");
                          id(kostal_webinterface_ready).publish_state(true);

                          id(sysfreemapmin).update();
                          id(sysfreeheap).update();

                        }else{

                            ESP_LOGE("system", "Fatal ERROR Http request data");
                            id(kostal_status).publish_state("Aus");
                            id(kostal_webinterface_status).publish_state("Error");
                            id(kostal_webinterface_ready).publish_state(false);

                          }    

                    - logger.log:
                        tag: "develop"
                        level: WARN
                        format: "End get Data"

                  else:
                    - logger.log:
                        tag: "system"
                        level: ERROR
                        format: "Kostal Webservice fatal Error"
                    - lambda: |-
                        // update the state info
                        id(kostal_status).publish_state("Aus");
                        id(kostal_webinterface_status).publish_state("Error");
                        id(kostal_webinterface_ready).publish_state(false);

            - then:
                - text_sensor.template.publish:
                    id: kostal_datatime
                    state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

                - sensor.template.publish:
                    id: kostal_data_timeout
                    state: !lambda |-
                      int time_used = ( millis() - id(send_millisecond) );
                      id(send_millisecond) = millis();
                      return float(time_used)/1000;

  # update all history data sensors based on the global vars
  # - id: updateHistorydata
  #   then:
  #     - logger.log:
  #         tag: "develop"
  #         level: DEBUG
  #         format: "Update Historydata"
  #     - lambda: |-
  #         // update the history
  #         if(id(kostal_day).has_state()){
  #           if(id(last_value) > 0.00 and id(kostal_day).state > 0.00){
  #             float v = id(kostal_day).state - float(id(last_value));
  #             id(hour_value)+=v;
  #             id(week_value)+=v;
  #             id(month_value)+=v;
  #             id(year_value)+=v;
  #           }
  #           id(kostal_hour).publish_state( id(hour_value) );
  #           id(kostal_yesterday).publish_state( id(yesterday_value) );
  #           id(kostal_week).publish_state( id(week_value) );
  #           id(kostal_month).publish_state( id(month_value) );
  #           id(kostal_lastmonth).publish_state( id(lastmonth_value) );
  #           id(kostal_year).publish_state( id(year_value) );
  #           if( id(sunon)==1 and id(kostal_aktuell).state==0.00 ){
  #             ESP_LOGW("main", "Check Kostal Piko 5.5, no production !!!" );
  #           }   
  #           id(last_value) = id(kostal_day).state; 
  #         }
  #     - component.update: kostal_solar_panel_power
  #     - component.update: kostal_solar_panel_faktor

## ------------------------
## COMPONENT DEBUG
## ------------------------
debug:
  update_interval: 2s

## ------------------------
## SWITCHES
## ------------------------
switch:
  - platform: template
    name: "Boot Counter Reset"
    id: btn_bc
    icon: mdi:lock-reset
    turn_on_action:
      then:
        - lambda: id(boot_counter) = 0; id(bootcounter).publish_state(id(boot_counter));
        - logger.log:
            level: WARN
            tag: "system"
            format: "${device_name_short} reset boot counter o.k!"
        - component.update: bootcounter

  - platform: restart
    id: restart_device
    name: Device restart
    icon: mdi:restart

  - platform: safe_mode
    name: "Device restart Safe Mode"
    id: btn_rsm
    icon: mdi:restart

  - platform: factory_reset
    name: Device restart factory defaults
    id: btn_fcr
    icon: mdi:restart

## ------------------------
## DOMAIN SELECT
## ------------------------
select:
  - platform: template
    name: Testcase Mode
    id: datamode
    disabled_by_default: true
    options:
      - "Simulate"
      - "Static_html_day"
      - "Static_html_night"
      - "Production"
    initial_option: "Simulate"
    optimistic: true    
    on_value:
      then:        
        - select.set_index:
            id: kostal_datasource
            index: !lambda return i;
        - delay: 200ms
        - logger.log:
            tag: "system"
            level: WARN
            format: "Testcase Mode %s, (index %d)"
            args:
              - x.c_str()
              - id(datamode).active_index().value()
        - script.execute: loadKostalData            
        - script.wait: loadKostalData
            
  - platform: template
    name: Datasource Kostal
    id: kostal_datasource
    disabled_by_default: true
    internal: true
    options:
      - ${data_kostalurl}
      - ${data_kostalurl1}
      - ${data_kostalurl2}
      - ${data_kostalurl}    
    optimistic: true    
    on_value:
      then:
        - logger.log:
            tag: "system"
            level: WARN
            format: "Datasource Kostal Mode is %s: url: %s (index %d)"
            args:
              - id(datamode).state.c_str()
              - x.c_str()
              - id(datamode).active_index().value()

        

## ------------------------
## BINARY SENSORS
## webserver no mdi:icons !
## ------------------------
binary_sensor:
  # Einspeisen MPP
  - platform: template
    name: "Energie Produktion aktiv"
    icon: mdi:solar-power-variant-outline
    id: kostal_production_on
    lambda: return id(kostal_status).has_state() and id(kostal_status).state == id(pikostateon);

  # Webinterface Kostal Piko ready
  - platform: template
    name: "Kostal Pico Status"
    icon: mdi:lightning-bolt-circle
    id: kostal_webinterface_ready
  # Check production
  - platform: template
    name: "Energie Produktion"
    icon: mdi:toggle-switch-variant-off
    id: sun_production_on
    lambda: return (id(sunon)==1 and id(kostal_aktuell).has_state() and id(kostal_aktuell).state > 0.00 );

## ------------------------
## SENSORS
## ------------------------
sensor:
  # aktuelle Leistung (updated by script): kostal_l1_power + kostal_l2_power + kostal_l3_power
  - platform: template
    name: "Leistung aktuell"
    id: kostal_aktuell
    icon: mdi:solar-power-variant
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"

  # Energie Produktion pro Tag (updated by script)
  - platform: template
    name: "Energie Tag"
    id: kostal_day
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "kWh"

  # Energie Produktion gesamt seit installation (updated by script)
  - platform: template
    name: "Energie Gesamt"
    id: kostal_total
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "kWh"

  # Leistung Produktion Phase 1 (updated by script)
  - platform: template
    name: "Energie L1"
    id: kostal_l1_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"

  # Leistung Produktion Phase 2 (updated by script)
  - platform: template
    name: "Energie L2"
    id: kostal_l2_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"

  # Leistung Produktion Phase 3 (updated by script)
  - platform: template
    name: "Energie L3"
    id: kostal_l3_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "W"

  # Solar Panel Leistung (simple, just a testcase)
  # better get the current power from solcast.com
  # https://solcast.com/solar-radiation-map/europe
  - platform: template
    name: "Solar Panel Leistung"
    id: kostal_solar_panel_power
    icon: mdi:solar-power
    accuracy_decimals: 2
    state_class: measurement
    device_class: energy
    unit_of_measurement: "W"
    lambda: |-
      if(id(sun_elevation).has_state()){
        ESP_LOGD("kostal", "Installierte Leistung %.2f, Sonnenhöhe:%.2f", id(kwhpeak),id(sun_elevation).state); 
        return (id(kwhpeak)*id(sun_elevation).state*0.01);
      }else{
       ESP_LOGW("kostal", "Keine Solarleistung vorhanden, Sonnenhöhe:%.2f", id(sun_elevation).state); 
       return 0.00;
      }

  # theortischer Leistungsfakor = aktuelle Leistung / Sonnen Leistung
  - platform: template
    name: "Solar Leistungsfaktor"
    id: kostal_solar_panel_faktor
    icon: mdi:percent-outline
    accuracy_decimals: 2
    state_class: measurement
    unit_of_measurement: "%"
    lambda: |-
      if(id(kostal_aktuell).has_state() and id(kostal_solar_panel_power).has_state() and id(kostal_solar_panel_power).state>0.00){               
         return (id(kostal_aktuell).state / id(kostal_solar_panel_power).state)*100;
      }else{
         ESP_LOGW("kostal", "Kein Leisungsfaktor, Kostal:%.2f,  Sonnenleistung: %.2f",id(kostal_aktuell).state, id(kostal_solar_panel_power).state);
         return 0.00;
      }

  # Leistung Produktions Anteil Ost (updated by script)
  - platform: template
    name: "Energie Anteil Ost"
    id: kostal_power_east
    icon: mdi:home-percent-outline
    accuracy_decimals: 2
    state_class: measurement
    unit_of_measurement: "%"

  # Leistung Produktions Anteil Ost (updated by script)
  - platform: template
    name: "Energie Anteil West"
    id: kostal_power_west
    icon: mdi:home-percent-outline
    accuracy_decimals: 2
    state_class: measurement
    unit_of_measurement: "%"

  # aktuelle Sonnenhöhe
  # default: updates based on the datadelay settings
  - platform: sun
    name: Sonnehöhe
    id: sun_elevation
    type: elevation

  # aktuelle Sonnenrichtung
  - platform: sun
    name: Sonnenrichtung
    id: sun_anzimuth
    type: azimuth

  # Wifi quality RSSI (%)
  - platform: wifi_signal
    name: "Device WLAN Signal"
    id: wifi_signal_db
    update_interval: 60s
    icon: mdi:wifi
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    entity_category: "diagnostic"
    unit_of_measurement: "%"

  # Uptime device in hours
  - platform: uptime
    name: Device online seit
    id: uptime_human
    icon: mdi:clock-start
    filters:
      - lambda: return x / 3600;
    unit_of_measurement: "h"
    entity_category: "diagnostic"
    state_class: "measurement"
    accuracy_decimals: 2

  # device internal temperature (only webview)
  - platform: internal_temperature
    name: Device Internal Temperature
    id: device_internal_temperature
    icon: mdi:thermometer-lines
    state_class: "measurement"
    update_interval: 60s
    entity_category: "diagnostic"
    disabled_by_default: true

  # device boot counter by device boot
  - platform: template
    name: "Boot counter"
    id: bootcounter
    icon: mdi:counter
    accuracy_decimals: 0
    state_class: "measurement"
    entity_category: "diagnostic"
    lambda: return (id(boot_counter));

  # service call delay (updated by script)
  - platform: template
    name: Kostal Daten Intervall
    id: kostal_data_timeout
    icon: mdi:clock-start
    accuracy_decimals: 2
    unit_of_measurement: "sec"
    state_class: "measurement"
    entity_category: "diagnostic"

  # the current size of free heap memory.
  - platform: template
    name: Free Heap Min
    id: sysfreemapmin
    icon: mdi:counter
    lambda: return {static_cast<float>(esp_get_minimum_free_heap_size())};
    unit_of_measurement: B
    update_interval: 2s
    entity_category: "diagnostic"
    on_value:
      then:
        - if:
            condition:
              lambda: return x < 30000.00;
            then:
              - logger.log:
                  level: ERROR
                  format: "WARNING FREE HEAP MAP is low: %f bytes"
                  args:
                    - x

  # Minimum free heap ever available
  - platform: template
    name: Free Heap
    id: sysfreeheap
    icon: mdi:counter
    lambda: return {static_cast<float>(esp_get_free_heap_size())};
    unit_of_measurement: B
    update_interval: 2s
    entity_category: "diagnostic"

  # only for logging
  - platform: debug
    free:
      name: "Heap Free"
      id: debug_heapfree
      disabled_by_default: true
    block:
      name: "Heap Max Block"
      id: debug_heapmaxblock
      disabled_by_default: true

## ------------------------
## TEXT SENSORS
## ------------------------
text_sensor:

  # Kostal status (updated by script)
  - platform: template
    name: "Kostal Pico Status"
    id: kostal_status
    disabled_by_default: true
    icon: mdi:alarm-note

  # Kostal webinterface status (updated by script)
  - platform: template
    name: "Kostal Pico Verbindung"
    id: kostal_webinterface_status
    icon: mdi:alarm-note

  # Kostal Daten Zeitstempel (updated by script)
  - platform: template
    name: "Kostal Pico Timestamp"
    id: kostal_datatime
    icon: mdi:clock-start
    disabled_by_default: true

  # Zeit Sonnenaufgang
  - platform: sun
    name: Sonnenaufgang am
    id: sun_sunrise
    type: sunrise

  # Zeit Sonnenaufgang
  - platform: sun
    name: Sonnenuntergang am
    id: sun_sunset
    type: sunset

  # Last boot timestamp (updated by device boot)
  - platform: template
    name: "Device Last Boot"
    id: device_lastBoot_time
    icon: mdi:clock-start
    disabled_by_default: true
    on_value:
      then:
        - logger.log:
            level: DEBUG
            format: "device_lastBoot_time changed"
        - script.execute: loadKostalData            
        - script.wait: loadKostalData

  # optional device timestamp (only for webserver)
  # default: updates every minute (60s)
  - platform: template
    id: systime
    name: Device Uhrzeit
    disabled_by_default: true
    icon: mdi:clock-start
    lambda: return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");

  # connected to ssid (only for webserver)
  - platform: wifi_info
    ssid:
      name: Device WLAN SSID
      id: wlan_ssid
      disabled_by_default: true
      icon: mdi:wifi-settings

  # installed esphome version
  - platform: version
    name: "ESPHome Version"
    id: eshome_version
    hide_timestamp: true
    disabled_by_default: true
    icon: mdi:information-box-outline
